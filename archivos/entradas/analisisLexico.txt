program {
	<<CASOS DE PRUEBA
	f32 x,y,z,w;
	i32 i;
	<< Punto flotante en el limite del rango superior, funciona correctamente
	x =: 3.40282347F38; 

	<< Punto flotante fuera del limite del rango superior, arroja error fuera de rango
	y =: 3.40282348F38; 

	<< Punto flotante en el limite del rango inferior, funciona correctamente
	z =: 1.17549435F-38; 

	<< Punto flotante fuera del limite del rango inferior, arroja error fuera de rango
	w =: 1.17549436F-38; 

	<< maximo entero positivo
	i =: 2147483647; 

	<< maximo entero positivo fuera de rango, arroja error fuera de rango
	i =: 2147483648; 

	<< maximo entero negativo
	i =: -2147483648;  

	<< maximo entero negativo fuera de rango, arroja error fuera de rango
	i =: -2147483649; 

	<< Testeo numeros flotantes y sus alternativas.
	f32 e;
	e =: .08;
	e =: 3.00;
	e =: 3.00F2;
	e =: 3.00F-2;

	<< Identificadores de mas y menos de 25 caracteres
	i32 pruebadeidentificadordemasdeveinticincocaracteres;
	i32 identificador;

	<< Identificadores con letras, digitos y -
	f32 hola;
	i32 hola123;
	i32 hola_prueba;

	<<Intento de incluir en el nombre de un identificador un caracter que no sea letra, digito o -.
	i32 prue.ba;

	<<Palabras reservadas escritas en minúsculas y mayúsculas .
	if (hola < 3) then {
	} end_if;

	IF (hola >= 3) THEN {
	} END_IF;

	<<cadena mal escrita, arroja error lexico
	<<out(`hola);

	<< cadena bien escrita
	out(`hola`);

	<< cadena multilinea
	<<out( `prueba de cadena\
	<<multilinea`);
	


	<< SENTENCIAS DECLARATIVAS
	
	<<declaracion de variables de tipo enteras
	i32 x;
	i32 a, b,c;

	<<declaracion de variables de tipo flotantes
	f32 z;
	f32 y,w,d;

      << declaracion de funcion con retorno de tipo entero
      fun cumple(i32 a,i32 b): i32 {
		i32 z;
		z=: a + b;
            return (z);
      };

	<< declaracion de funcion con retorno de tipo flotante
	fun cumple1(f32 a, f32 b): f32 {
		f32 z;
		z=: a + b;
		return (z);
	};

      << funcion con varios retornos
      fun cumple2 (i32 a, i32 b): i32 {
          if (a < b) then { 
              return (a);
         }
          else {
              return (3);
         }
          end_if;
      };

	<< declaracion de constantes
      const a =: 3,b =:2;

      <<funcion con varios retornos y continue con etiquetado
      fun cumple3 (i32 a,i32 b): i32 {
          if (a < b) then { 
              outer: while ( i < 10 ) : (i =: i + 1 ) {
              	while ( j < 5 ) : (j =: j + 1 ) {
                  	continue :outer;
                        return (a);    
                  };           
              };
          }
          else {
              return (3);
          }
          end_if;
      };

	<< SENTENCIAS EJECUTABLES
	
	<< asignacion
	a =: 3 + 1;

	<<funcion como expresion asignada a una variable
	a =: cumple (a,b);
	
	<< sentencia out
	out (`hola`);

	<<senteincia when
	when( a > b ) then 
      { 
      	a =: 3 ;
      };
	
	<< sentencia while
	while ( i < 10 ) : (i =: i + 1 ) {
          out ( `test` );
     	};

	<<sentencia for
	for ( i =: n ; i < 10 ; +1){
          a =: 3; 
      };
	
	<<sentencia for con continue y break
	for ( i =: n ; i < 10 ; +1){
      	if (a < b) then {
            	continue; 
            }
            else {
            	break;
            } end_if;
      };

	<< continue con etiquetado
	outer: while ( i < 10 ) : (i =: i + 1 ) {
      		while ( j < 5 ) : (j =: j + 1 ) {
            		continue :outer;     
            	};           
            };
	
	<< sentencia de control como expresion
	a =:  for (i =: 0 ;i < end ; +1){
           		if (i = number) then {
                  	break 1;
                  } end_if;
              }else 3;

	<< ERRORES

	<< las sentencias declarativas pueden aparecer en cualquier lugar del codigo fuente exceptuando los bloques de sentencias de control
	while (i < 10 ) : (i =: i + 1 ) {
		i32 a;
	};
	
	i32 b;

	fun prueba(f32 a): f32 {
		f32 z;
		z=: a + b;
		return (z);
	};


	fun prueba1(): f32 {
		return (3);
	};

	fun prueba1(f32 a): f32 {
		return (a);
	};

	fun prueba1(f32 a, f32 b): f32 {
		return (a);
	};
	
	fun prueba1(f32 a, f32 b, f32 c): f32 {
		return (a);
	};
	
	<< No se deben permitir anidamientos de expresiones con parentesis
	c =: (a + b ) / c;

	
}