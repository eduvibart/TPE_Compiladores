program {
	
    <<VARIABLES NO DECLARADAS

    << la variable a aun no esta declarada 
    if (a = 3) then {

    } end_if;
    
    i32 b;
    
    << a aun no esta declarada pero b si
    a=:b;
	b=:a;
    
    << declaracion de la variable a
    i32 a;

    << falta declarar la variable c
    while (a>b):(c=:a+1){

    };

    << falta declarar la variable c
    while (a>b):(a=:a+1){
        c=:b;
    };

    i32 c;

    << todo declarado
    while (a>b):(a=:c+1){
        c=:a+1;
        a=:c;
    };


    <<VARIABLES REDECLARADAS

    f32 d;  << declaracion de la variable d
     
    f32 d; << intento de redeclaracion de d en el mimso ambito con el mismo tipo 

    i32 d; << intento de redeclaracion de d en el mismo ambito con distinto tipo

    fun funRedeclaracionVariable(): f32{
        f32 d; << redeclaracion con el mismo tipo en otro ambito
        return (3.0);
    };

    fun funRedeclaracionVariable1(): f32{
        i32 d; << redeclaracion con otro tipo en otro ambito
        return (3.0);
    };


    <<FUNCIONES REDECLARADAS

    <<declaracion de la funcion funRedeclaracion
    fun funRedeclaracion(): i32{
        return (3);
    };

    <<intento de redeclaracion de la funcion funRedeclaracion en el mismo ambito con el mismo tipo
    fun funRedeclaracion(): i32 {
        return (3);
    };

    <<intento de redeclaracion de la funcion funRedeclaracion en el mismo ambito con distinto tipo
    fun funRedeclaracion(): f32 {
        return (3.0);
    };

    <<redeclaracion de la funcion funRedeclaracion con el mismo tipo en un ambito distinto
    fun funRedeclaracion1(): i32 {
        fun funRedeclaracion1():i32{
            return (3);
        };
        return (3);
    };

    <<redeclaracion de la funcion funRedeclaracion con distinto tipo en un ambito distinto
    fun funRedeclaracion2(): i32 {
        return (3);
        fun funRedeclaracion1():f32{
            return (3.0);
        };
    };

    <<CADA VARIABLE O FUNCION SERA VISIBLE DENTRO DEL AMBITO EN EL QUE FUE DECLARADA Y POR LOS AMBTIOS ANIDADOS CONTENIDOS EN EL AMBITO DE DECLARACION

    fun funAlcanceVariables0():i32{
        
        << declaracion de la variable e dentro de funAlcanceVariables0
        i32 e;

        << declaracion de la funcion funAlcanceVariables01
        fun funAlcanceVariables01():i32{

            << alcance de la variable e declarada en el ambito de la funcion funAlcanceVariables0 (padre de funAlcanceVariables01)
            e=:4;

            fun funAlcanceVariables02():i32{

                << alcance de la variable e declarada en el ambito de la funcion funAlcanceVariables0 (abuelo de funAlcanceVariables02)
                e=:5;

                << alcance de la funcion padre funAlcanceVariables01
                funAlcanceVariables01();
                return (8);
            };
            return (8);
        };

        fun funAlcanceVariables03():i32 {
            << alcance de la variable e declarada en el ambito de la funcion funAlcanceVariables0 (padre de funAlcanceVariables01)
            e=:6;

            << alcance de la funcion hermana funAlcanceVariables01
            
            return (funAlcanceVariables01());
        };
        return (c); 
    };

    fun funAlcanceVariables04():i32{
        
        <<intento de alcance a la variable e declarada dento de la funcion funAlcanceVariables0 (hermana de funAlcanceVariables04)
        e=:7;

        <<intento de alcance de la funcion funAlcanceVariables01
        funAlcanceVariables01();
        return (c); 
    };


    <<SE PERMITEN VARIABLES CON EL MISMO NOMBRE, SIEMPRE QUE SEAN DECLARADAS EN DIFERENTES AMBITOS.
    
    <<declaracion de f en general
    i32 f;

    fun declarcionMismoNombreVar():i32{

        <<declaracion de f en ambito de funDeclarcionMismoNombre
        i32 f;

        fun declarcionMismoNombreVar1():i32{

            <<declaracion de f en ambito de funDeclarcionMismoNombre1
            i32 f;
            return (f);
        };

        fun declarcionMismoNombreVar2():i32{

            <<declaracion de f en ambito de funDeclarcionMismoNombre2
            i32 f;
            return (f);
        };
        return (f);
    };



    <<SE PERMITEN FUNCIONES CON EL MISMO NOMBRE, SIEMPRE QUE SEAN DECLARADAS EN DIFERENTES AMBITOS.

    <<declaracion de funcion funDeclarcionMismoNombreFun

    fun funDeclarcionMismoNombre():i32{
        return (9+c);
    };

    fun funDeclarcionMismoNombre1():i32{
        
        <<declaracion de funcion con el mismo nombre (funDeclarcionMismoNombre) en amito distinto 
        fun funDeclarcionMismoNombre():i32{
            return (7+5);
        };
        return (7+5);
    };

    <<intento de declaracion de funcion con el mismo nombre en mismo ambito general (funDeclarcionMismoNombre)
    fun funDeclarcionMismoNombre():i32{
        return (5);
    };



    
    <<SE PERMITEN ETIQUETAS CON EL MISMO NOMBRE SIEMPRE QUE SEAN DECLARADAS EN DIFERENTES AMBITOS

    etiquetaPrueba : while (a > b): (a=:a+1){

    };

    fun cambiaAmbito():f32{

        <<misma etiqueta en distinto ambito
        etiquetaPrueba : while (a>b): (a=:a+1){

        };
        return (2.0);
    };

    << intento de utilizar misma etiqueta en mismo ambito
    etiquetaPrueba: for (a =: 0 ; a < b ; +1 ){

    };

    

    <<SOLO SE PODRA EFECTUAR UNA OPERACION ENTRE OPERANDOS DEL MISMO TIPO

    i32 g,h,i;
    f32 j,k,l;
    
    <<asignacion:
    g=:h;
    j=:k;
    <<intento de asignacion entre distintos tipos:
    g=:j;
    j=:g;

    <<expresion:
    g=: h+i;
    j=: k+l;
    <<intento de expresion entre distintos tipos:
    g=: k+l;
    g=: h-k;
    k=: l/g;
    k=: h*l;


    << comparacion:
    if (g>h) then {

    }end_if;
    <<intneto de comparacion entre distintos tipos:
    if(g>k)then{

    }end_if;

    << asignacion con expresion y funcion
    fun pruebaTipoEntero():i32{
        i32 m;
        return(m);
    };
    fun pruebaTipoFlotante():f32{
        f32 n;
        return(n);
    };

    g=: h + pruebaTipoEntero();
    
    <<intento con funcion de distinto tipo
    g=: h +pruebaTipoFlotante();



    <<EL NUMERO DE LOS PARAMETROS REALES DE UNA INVOCACION A FUNCION DEBEN COINCIDIR CON EL NUMERO DE PARAMETROS DECLARADOS PARA LA FUNCION
    fun funSinParametros():i32{
        return (6);
    };
    fun funConUnParametro(i32 a):i32{
        return (6);
    };
    fun funConDosParametros(i32 a, i32 b):i32{
        return (6);
    };

    <<llamado a fun sin parametros
    funSinParametros();
    << intento de llamado a fun sin parametros con uno y dos parametros
    funSinParametros(g);
    funSinParametros(g,h);

    <<llamado a fun con un parametro
    funConUnParametro(g);
    <<intento de llamado a fun con un parametro sin y con 2 parametros
    funConUnParametro();
    funConUnParametro(g,h);

    <<llamado a fun con dos parametros
    funConDosParametros(g,h);
    <<intento de llamado a fun con dos parametros sin y con un parametro
    funConDosParametros();
    funConDosParametros(g);


    <<CHECKEO DE COMPATIBILIDAD EN LLAMADO A FUNCIONES
    fun funConParametroEntero(i32 a):i32{
        return (8);
    };
    fun funConParametroFlotante(f32 b):f32{
        return (8);
    };

    << g es una variable de tipo entero y j es de tipo flotante (declaradas previamente)

    <<llamado correctamente
    funConParametroEntero(g);
    funConParametroFlotante(k);

    <<intento de llamado con parametros de distinto tipo
    funConParametroEntero(k);
    funConParametroFlotante(g);

    << funcion sin retorno
    fun funSinRetorno(i32 a):i32{
        
    };

    << funcion con retorno de otro tipo
    fun funConRetornoErroneo(i32 a):i32{
        return (2.0);
    };
    
    <<INTENTO DE REFERENCIA A UNA ETIQUETA

    << se define un while con etiqueta etiquetaWhile
    etiquetaWhile : while (i<10): (i=:i+1){
        
        while (i<5):(i=:i+1){
        
            << salto a la etiqueta etiquetaWhile ya existente.
            continue : etiquetaWhile;
        
        };
    
    };

    <<intento de salto a una etiqueta no definida
    while (i<5):(i=:i+1){

        continue : etiquetaNoExistente;
    };

    <<intento de salto a una etiqueta con el nombre de un identificador
    while (i<5): (i=: i+1){
        
        continue : a;
    };
}